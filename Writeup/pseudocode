


"""
Flood fill BFS algorithm.
"""

FUNC FloodFill(src_x:INT, src_y:INT, image:2d-ARRAY, new_colour:TUPLE): RETURNS 2d-ARRAY
    
    old_colour = image[scr_x][scr_y]

    IF old_colour = new_colour THEN
        END FUNC
    END IF

    enqueue((src_x, scr_y))

    directions = [(1,0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, -1), (-1, 1)]

    image[scr_x][scr_y] = new_colour
    
    WHILE queue not empty
        item = dequeue
        x = item[0]
        y = item[1]

        FOR dx, dy in directions
            new_x = x + dx
            new_y = y + dy

            IF 0 <= nx < rows AND 0 <= ny < cols AND image[new_x][new_y] == old_colour THEN
                image[new_x][new_y] = new_colour
                enqueue((new_x, new_y))
            END IF
        
END FUNC




"""
Demonstrating how to use JAX immutable arrays
"""
import numpy as np
import jax.numpy as jnp

#initialising the array
array = jnp.array()
#creating a new array with the modified values according to the original array
array = array.at[i].set(x)

#This is the same as the following numpy
array = np.array()
array[i] = x


"""
scrollable buttons algorithm
"""

PROC render_scrollable_list(items:ARRAY, scroll_y: INT):
    FOR ITEM and INDEX IN items:
        item_rect = RECT(x_pad, INDEX*height, width, height)
        if 0 <= item_rect.y <= SCREEN_HEIGHT:
            DRAW item_rect
            text = FONT(item, colour)
            DRAW(text, (item_rect.x + text_x_pad, item_rect.y + text_y_pad))
END PROC








"""
Flood fill start point finder

1	Find the bottom-most point in the aerofoil perimeter
2	Find the 2 adjacent point to this point
3	Find the vector which goes from one to the other adjacent point
4	Find the perpendicular midpoint bisector of this vector
5	Clamp this vector to the 8 cardinal directions to limit vector length
6	Add the clamped vector to the bottom-most node to get the start-point
"""

FUNC flood_fill_start_finder(save_path: ARRAY):
    lowest_point = (10000, 10000)
    FOR i=0 to LEN(save_path):
        point = save_path[i]
        if point[1] < lowest[1]:
            lowest = point
    
    index = save_path.index(lowest)
    left_point = save_path[index-1]
    right_point = save_path[index+1]

    vector = (left_point[0]-right_point[0], left_point[1]-right_point[1])
    normal_vector = (-vector[1], vector[0])

    cardinal_direction = (INT(clamp(normal_vector[0]), -1, 1), INT(clamp(normal_vector[1]), -1, 1))

    start_point = (lowest[0] + cardinal_direction[0], lowest[1] + cardinal_direction[1])

    RETURN start_point
END FUNC